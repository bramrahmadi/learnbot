name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy (SHA from staging)"
        required: true
        type: string
      confirm:
        description: "Type 'deploy' to confirm production deployment"
        required: true
        type: string

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  ENVIRONMENT: production

concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  # â”€â”€â”€ Validation Gate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  validate:
    name: Validate Deployment Request
    runs-on: ubuntu-latest

    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "deploy" ]; then
            echo "âŒ Deployment not confirmed. Type 'deploy' to confirm."
            exit 1
          fi
          echo "âœ… Deployment confirmed"

      - name: Validate image tag format
        run: |
          TAG="${{ github.event.inputs.image_tag }}"
          if [[ ! "$TAG" =~ ^[a-f0-9]{40}$ ]]; then
            echo "âŒ Invalid image tag format. Must be a full 40-character SHA."
            exit 1
          fi
          echo "âœ… Image tag is valid: $TAG"

  # â”€â”€â”€ Pre-deployment Checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  pre-deploy-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    needs: validate
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify images exist in ECR
        run: |
          for SERVICE in api-gateway resume-parser job-aggregator learning-resources frontend; do
            echo "Checking $SERVICE:${{ github.event.inputs.image_tag }}..."
            aws ecr describe-images \
              --repository-name "learnbot-staging/$SERVICE" \
              --image-ids imageTag=${{ github.event.inputs.image_tag }} \
              --region ${{ env.AWS_REGION }} > /dev/null
            echo "âœ… $SERVICE image found"
          done

      - name: Check staging health
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://staging-api.learnbot.example.com/health)
          if [ "$STATUS" != "200" ]; then
            echo "âŒ Staging is not healthy (status: $STATUS). Aborting production deployment."
            exit 1
          fi
          echo "âœ… Staging is healthy"

      - name: Create deployment record
        run: |
          echo "Deployment started at $(date -u +%Y-%m-%dT%H:%M:%SZ)" > deployment-record.txt
          echo "Image tag: ${{ github.event.inputs.image_tag }}" >> deployment-record.txt
          echo "Triggered by: ${{ github.actor }}" >> deployment-record.txt

  # â”€â”€â”€ Database Backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  backup-database:
    name: Backup Production Database
    runs-on: ubuntu-latest
    needs: pre-deploy-checks
    environment: production

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create RDS snapshot before deployment
        run: |
          SNAPSHOT_ID="pre-deploy-${{ github.event.inputs.image_tag }}-$(date +%Y%m%d%H%M%S)"
          aws rds create-db-snapshot \
            --db-instance-identifier learnbot-production-postgres \
            --db-snapshot-identifier "$SNAPSHOT_ID" \
            --region ${{ env.AWS_REGION }}

          echo "Waiting for snapshot to complete..."
          aws rds wait db-snapshot-completed \
            --db-snapshot-identifier "$SNAPSHOT_ID" \
            --region ${{ env.AWS_REGION }}

          echo "âœ… Snapshot created: $SNAPSHOT_ID"
          echo "SNAPSHOT_ID=$SNAPSHOT_ID" >> $GITHUB_ENV

  # â”€â”€â”€ Run Migrations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  migrate-production:
    name: Run Database Migrations (Production)
    runs-on: ubuntu-latest
    needs: backup-database
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run migrations via ECS task
        run: |
          TASK_ARN=$(aws ecs run-task \
            --cluster learnbot-production-cluster \
            --task-definition learnbot-production-migrate \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ secrets.PROD_PRIVATE_SUBNET_IDS }}],securityGroups=[${{ secrets.PROD_ECS_SG_ID }}],assignPublicIp=DISABLED}" \
            --overrides '{"containerOverrides":[{"name":"migrate","command":["migrate","up"]}]}' \
            --query 'tasks[0].taskArn' \
            --output text)

          echo "Migration task ARN: $TASK_ARN"

          aws ecs wait tasks-stopped \
            --cluster learnbot-production-cluster \
            --tasks "$TASK_ARN"

          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster learnbot-production-cluster \
            --tasks "$TASK_ARN" \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)

          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Migration failed with exit code: $EXIT_CODE"
            exit 1
          fi
          echo "âœ… Migrations completed successfully"

  # â”€â”€â”€ Deploy to Production â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-production:
    name: Deploy to Production ECS
    runs-on: ubuntu-latest
    needs: migrate-production
    environment:
      name: production
      url: https://learnbot.example.com

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Promote images from staging to production ECR
        run: |
          for SERVICE in api-gateway resume-parser job-aggregator learning-resources frontend; do
            echo "Promoting $SERVICE..."
            MANIFEST=$(aws ecr batch-get-image \
              --repository-name "learnbot-staging/$SERVICE" \
              --image-ids imageTag=${{ github.event.inputs.image_tag }} \
              --query 'images[0].imageManifest' \
              --output text)

            aws ecr put-image \
              --repository-name "learnbot-production/$SERVICE" \
              --image-tag ${{ github.event.inputs.image_tag }} \
              --image-manifest "$MANIFEST"

            aws ecr put-image \
              --repository-name "learnbot-production/$SERVICE" \
              --image-tag latest \
              --image-manifest "$MANIFEST"

            echo "âœ… $SERVICE promoted"
          done

      - name: Deploy API Gateway to Production ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: infrastructure/ecs/task-definitions/api-gateway.production.json
          service: learnbot-production-api-gateway
          cluster: learnbot-production-cluster
          wait-for-service-stability: true
          image-ids: |
            containerName=api-gateway,imageUri=${{ env.ECR_REGISTRY }}/learnbot-production/api-gateway:${{ github.event.inputs.image_tag }}

      - name: Deploy Resume Parser to Production ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: infrastructure/ecs/task-definitions/resume-parser.production.json
          service: learnbot-production-resume-parser
          cluster: learnbot-production-cluster
          wait-for-service-stability: true
          image-ids: |
            containerName=resume-parser,imageUri=${{ env.ECR_REGISTRY }}/learnbot-production/resume-parser:${{ github.event.inputs.image_tag }}

      - name: Deploy Job Aggregator to Production ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: infrastructure/ecs/task-definitions/job-aggregator.production.json
          service: learnbot-production-job-aggregator
          cluster: learnbot-production-cluster
          wait-for-service-stability: true
          image-ids: |
            containerName=job-aggregator,imageUri=${{ env.ECR_REGISTRY }}/learnbot-production/job-aggregator:${{ github.event.inputs.image_tag }}

      - name: Deploy Learning Resources to Production ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: infrastructure/ecs/task-definitions/learning-resources.production.json
          service: learnbot-production-learning-resources
          cluster: learnbot-production-cluster
          wait-for-service-stability: true
          image-ids: |
            containerName=learning-resources,imageUri=${{ env.ECR_REGISTRY }}/learnbot-production/learning-resources:${{ github.event.inputs.image_tag }}

  # â”€â”€â”€ Post-deployment Verification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  verify-production:
    name: Verify Production Deployment
    runs-on: ubuntu-latest
    needs: deploy-production

    steps:
      - name: Wait for services to stabilize
        run: sleep 60

      - name: Health check - Production API
        run: |
          for i in {1..15}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://api.learnbot.example.com/health)
            if [ "$STATUS" = "200" ]; then
              echo "âœ… Production API is healthy"
              exit 0
            fi
            echo "Attempt $i: Status $STATUS, retrying in 15s..."
            sleep 15
          done
          echo "âŒ Production health check failed"
          exit 1

      - name: Tag successful deployment in git
        if: success()
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git tag "deploy-production-$(date +%Y%m%d%H%M%S)-${{ github.event.inputs.image_tag }}"
          git push origin --tags

      - name: Notify production deployment success
        if: success()
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "ğŸš€ Production deployment successful!\nImage: ${{ github.event.inputs.image_tag }}\nDeployed by: ${{ github.actor }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify production deployment failure
        if: failure()
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "ğŸ”¥ Production deployment FAILED!\nImage: ${{ github.event.inputs.image_tag }}\nDeployed by: ${{ github.actor }}\nRun: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\nâš ï¸ Consider rollback!"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # â”€â”€â”€ Rollback Job â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  rollback:
    name: Rollback Production (Manual)
    runs-on: ubuntu-latest
    needs: verify-production
    if: failure()
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback ECS services to previous task definition
        run: |
          for SERVICE in api-gateway resume-parser job-aggregator learning-resources; do
            echo "Rolling back $SERVICE..."
            PREV_TASK_DEF=$(aws ecs describe-services \
              --cluster learnbot-production-cluster \
              --services "learnbot-production-$SERVICE" \
              --query 'services[0].deployments[?status==`PRIMARY`].taskDefinition' \
              --output text | head -1)

            # Get the previous revision
            FAMILY=$(echo $PREV_TASK_DEF | cut -d: -f1 | rev | cut -d/ -f1 | rev)
            CURRENT_REV=$(echo $PREV_TASK_DEF | cut -d: -f2)
            PREV_REV=$((CURRENT_REV - 1))

            aws ecs update-service \
              --cluster learnbot-production-cluster \
              --service "learnbot-production-$SERVICE" \
              --task-definition "$FAMILY:$PREV_REV" \
              --force-new-deployment

            echo "âœ… $SERVICE rollback initiated"
          done

      - name: Notify rollback
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "âª Production rollback initiated!\nFailed image: ${{ github.event.inputs.image_tag }}\nRun: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
